![](https://velog.velcdn.com/images/guysang/post/d3fff312-0ea1-4986-9a70-03cba5627de8/image.png)

이번엔 단위 테스트에 대해 다뤄보려구 한다.

앱을 만들때 우리는 수 많은 문제들을 생각하고 로직이 잘 작동하는지 확인해야한다.

기존에 앱을 만들고 중간중간 확인을 하게 되면 시간도 오래걸리고 여러번 반복해서 확인하기 힘들기 때문에 테스트를 한다.

## 테스트의 종류

테스트는 테스트의 대상범위나 성격에 따라 End-to-end Test, Integration Test, UnitTest등 으로 구분한다.

![](https://velog.velcdn.com/images/guysang/post/7095c4dc-84e9-49a3-94ff-598acdd37688/image.png)

디벨로퍼에 그림으로 설명되어 있는데,

End-to-end Test 같은 경우 전체 화면이나 사용자 흐름과 같이 앱의 큰 부분을 동시에 확인하고

Integration Test는 여러 단위 테스트가 합친 비즈니스 로직을 테스트한다.

UnitTest는 함수 단위로 유효성을 검증한다.

하나의 테스트에 하나 이상의 테스트가 존재할 수 있고, 각각의 조건에 대한 유효성을 검사한다.

이렇게 작성된 단위 테스트가 많을수록 해당 로직에 대한 신뢰도가 높아지고, 작게 쪼개진 단위 테스트는 해당 로직이 어떤 역할을 하는지 쉽게 파악할 수 있다.

그 외 위에 정의한 테스트들은 단위테스트들을 합쳐 좀더 넓은 범위에서 추가적인 테스트를 하는 것이다.


# TDD

단위 테스트를 할때 알아야할 단어다.

테스트 주도 개발이라는 의미로

코드를 설계할때 원하는 단계적 목표를 설정하고 
최초목표에 맞춘 테스트코드를 구축하고 그에 맞게 코드를 작성하기 때문에 다른사람과 의견충돌이 줄어든다.

## 테스트 코드의 작성 목적

- 코드의 안정성이 높다

- 기능을 추가하거나 변경되는 과정에서 발생할 수 있는 사이드이펙트를 줄일 수 있음.

- A라는 기능을 고치기위해 메소드를 쓰고 있는데 A뿐만아니라 B도 쓰고 있었다면,,, 이런 것들과 관련된 테스트코드를 작성을 해놨다면 테스트를 돌려보고 사이드 이펙트를 확인 할 수 있다.

- 해당코드와 작성된 목적을 명확하게 표현할 수 있음
    - 코드에 불필요한 내용이 들어가는 것을 비교적 줄일 수 있음, 테스트코드만 통과하면 되겠다! 이 목적을 가지면 불필요한 코드를 줄일 수 있음

## JUnit이란?

자바 진영의 대표적인 테스트프레임워크

단위 테스트를 위한 도구를 제공 //일반적으로 통합테스트는 비즈니스 로직 자체를 테스트

어노테이션 기반으로 테스트를 지원

단정문(어설트 Assert)으로 테스트 케이스의 기대값에 대해 수행 결과를 확인할 수 있음

### JUnit 모듈 설명

#### Jupiter

테스트의 실제 구현체는 별도 모듈을 역할을 수행하는데, 그 모듈 중 하나가 주피터 엔진임
이모듈은 주피터 api를 사용해 작성한 테스트 코드를 발견하고 실행하는 역할을 수행
개발자가 테스트 코드를 작성할 때 사용됨

#### Platform

테스트를 실행하기 위한 뼈대를 가지고 있다고 보면됨
테스트를 발견하고 테스트 계획을 생성하는 테스트엔진 인터페이스를 가지고 있다, 여기는 인터페이스고 주피터는 구현체
테스트엔진을 통해서 테스트를 발견하고 수행 및 결과를 보고함
각종 IDE연동을 보조하는 역할 수행(콘솔 출력 등)

#### Vintage

테스트엔진API 구현체 , JUnit 3,4를 구현하고 있음
기존 3,4버전으로 작성된 테스트 코드를 실행할때 사용


#### LifeCycle Annotation

@Test 테스트용 메소드를 표현하는 어노테이션
@BeforEach 각 테스트 메소드가 시작되기전에 실행되어야 하는 메소드를 표현
@AfterEach 각 테스트 메소드가 시작된 후 실행되어야 하는 메소드를 표현
@BeforeAll 테스트 시작전에 실행되어야 하는 메소드를 표현
@AfterAll 테스트 종료후에 실행되어야 하는 메소드를 표현


**Main Annotation**


#### @MockBean

테스트할 클래스에서 주입 받고 있는 객체에 대해 가짜 객체를 생성해주는 어노테이션
해당 객체는 실제 행위를 하지 않음
given() 메소드를 활용해서 가짜 객체의 동작에 대해 정의하여 사용할 수 있음

### 통합 테스트

통합 테스트는 여러 기능을 조합하여 전체 비즈니스 로직이 제대로 동작하는지 확인하는 것을 의미

통합 테스트의 경우, 모든 Bean을 로드하게 됨
 - 이 방법을 대규모 프로젝트에서 사용할 경우, 테스트를 실행할때마다 모든 빈을 스캔하고 로드하는 작업이 반복되어 매번 무거운 작업을 수행해야함

단위 테스트

단위테스트는 프로젝트에 필요한 모든 기능에 대한 테스트를 각각 진행하는 것을 의미

FIRST 원칙

Fast 테스트 코드의 실행은 빠르게 진행되어야함
Independent 독립적인 테스트가 가능해야 함
Repeatable 테스트는 매번 같은 결과를 만들어야함
Self-Validating 테스트는 그 자체로 실행하여 결과를 확인할 수 있어야함
Timely 단위테스트는 비즈니스 코드가 완성되기 전에 구성하고 테스트가 가능해야 함
       >> 코드가 완성되기 전부터 테스트가 따라와야 한다는 RDD의 원칙을 담고 있음


### 안드로이드에서 Junit 사용하기

프로젝트의 왼쪽에 보면 3개의 패키지가 기본적으로 있는데,

하나는 그 동안 쓰던 앱에 모든 정보가 들어가있어야하는 패키지이고

(androidTest)가 적힌 패키지는 계측 테스트 또는 UI테스트와 관련된 모든 코드를 넣을 것이므로 기본적으로 테스트에 필요한 모든 코드(예, Context,Fragment,Activity)를 넣는다

(Test)가 적힌 패키지는 모든 단위 테스트 패키지를 넣는다. 기본적으로 Android관련 라이브러리가 필요하지 않은 원시 코틀린 혹은 자바코드가 들어간다

```kotlin
object Validator {
    fun validateInput(amount: Int, desc: String): Boolean {
        return !(amount <= 0 || desc.isEmpty())
    }
}
```

여기 간단한 함수를 만들었다.

입력값을 토대로 Boolean타입으로 만드는 메소드이다

안드로이드 스튜디오에선 여기서 우클릭하고 Go to -> test를 누르면 테스트 코드를 만들 수  있다.

```kotlin
class ValidatorTest {

    @Test
    fun whenInputIsVaild() {
        val amount = 100
        val desc = "Some random desc"
        val result = Validator.validateInput(amount, desc)
        assertThat(result).isEqualTo(true)
    }
```
테스트 패키지에 코드를 만들었다.

![](https://velog.velcdn.com/images/guysang/post/97d4ab57-636a-4e5b-9db8-ee822df18357/image.png)

코드 오른쪽을 보면 play버튼이 있는데 이를 눌러서 단위 테스트가 가능하다

눌러보자

![](https://velog.velcdn.com/images/guysang/post/f9a2d889-abd0-4b9a-a2a2-bb5c71a66efd/image.png)

15초가 소요됬고 값이 성공적으로 반환된걸 볼 수 있다.
![](https://velog.velcdn.com/images/guysang/post/db6191ae-e84f-4103-b01d-b73028fe6ad8/image.jpg)

이전에 쓴 레포지토리 이용해 Mock을 사용해 테스트를 해보고 싶었는데

에러를 해결하지 못했다...

Unresolved reference: mockito 그래들에 다 추가 했는데 왜 안되는 걸까,,